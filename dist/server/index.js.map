{
  "version": 3,
  "sources": ["../../src/server/index.gbln", "../../src/runtime/vnode.gbln", "../../src/runtime/scheduler.gbln", "../../src/runtime/component.gbln", "../../src/runtime/hooks.gbln", "../../src/runtime/suspense.gbln", "../../src/index.gbln", "../../src/server/streaming.gbln"],
  "sourcesContent": ["import http from 'node:http';\nimport type { AppProps } from '../index.gbln';\nimport { App } from '../index.gbln';\nimport { renderVNodeToStream } from './streaming.gbln';\n\nexport interface ServerOptions {\n  host?: string;\n  port?: number;\n  streaming?: boolean;\n}\n\nexport async function renderToStream(props: AppProps) {\n  const vnode = App(props);\n  return renderVNodeToStream(vnode);\n}\n\nexport function createServer(options: ServerOptions = {}) {\n  const host = options.host ?? '127.0.0.1';\n  const port = options.port ?? 3000;\n  const streaming = Boolean(options.streaming);\n\n  const server = http.createServer(async (_req, res) => {\n    const props: AppProps = { title: 'Goblin Server', features: ['ssr', 'typed', 'fast'] };\n    if (streaming) {\n      res.setHeader('Content-Type', 'application/json; charset=utf-8');\n      res.setHeader('Transfer-Encoding', 'chunked');\n      try {\n        for await (const chunk of await renderToStream(props)) {\n          res.write(chunk);\n        }\n        res.end();\n      } catch (error) {\n        res.statusCode = 500;\n        res.end(JSON.stringify({ error: (error as Error).message }));\n      }\n      return;\n    }\n    const vnode = App(props);\n    res.setHeader('Content-Type', 'application/json');\n    res.end(JSON.stringify(vnode));\n  });\n\n  return {\n    listen(cb?: () => void) {\n      server.listen(port, host, cb);\n    },\n    close(cb?: (err?: Error) => void) {\n      server.close(cb);\n    }\n  };\n}\n\nexport async function renderToString(props: AppProps): Promise<string> {\n  const vnode = App(props);\n  return JSON.stringify(vnode, null, 2);\n}\n", "export const TEXT_TYPE = Symbol('GoblinText');\n\nexport type PrimitiveChild = string | number | boolean | null | undefined;\nexport type ComponentType<Props = Record<string, unknown>> = (props?: Props) => VNode | PrimitiveChild | Array<VNode | PrimitiveChild>;\nexport type VNodeType<Props = Record<string, unknown>> = string | ComponentType<Props> | typeof TEXT_TYPE;\n\nexport interface VNode<Props = Record<string, unknown>> {\n  type: VNodeType<Props>;\n  props: Props & { children?: VNodeChildren };\n  key: string | number | null;\n  el: Node | null;\n  children: NormalizedChildren;\n  shapeFlag: number;\n  appContext?: Record<string, unknown>;\n  component?: unknown;\n}\n\nexport type VNodeChild = VNode | PrimitiveChild;\nexport type VNodeChildren = VNodeChild | Array<VNodeChild>;\nexport type NormalizedChildren = Array<VNode | TextVNode>;\n\nexport interface TextVNode extends VNode {\n  type: typeof TEXT_TYPE;\n  children: string;\n}\n\nfunction normalizeChildren(children: Array<VNodeChild | Array<VNodeChild>>): NormalizedChildren {\n  const flat: NormalizedChildren = [];\n  for (const child of children) {\n    if (Array.isArray(child)) {\n      flat.push(...normalizeChildren(child as Array<VNodeChild | Array<VNodeChild>>));\n    } else if (child == null || child === false || child === true) {\n      continue;\n    } else if (typeof child === 'object') {\n      flat.push(child as VNode);\n    } else {\n      flat.push(createTextVNode(String(child)));\n    }\n  }\n  return flat;\n}\n\nexport function h<Props = Record<string, unknown>>(type: VNodeType<Props>, props: Props | null = null, ...children: Array<VNodeChild | Array<VNodeChild>>): VNode<Props> {\n  const normalizedChildren = normalizeChildren(children);\n  const key = props && (props as Record<string, unknown>).key != null ? (props as Record<string, unknown>).key : null;\n  const nextProps = props ? { ...(props as Record<string, unknown>) } : {};\n  if (key != null) {\n    delete (nextProps as Record<string, unknown>).key;\n  }\n  if (normalizedChildren.length > 0) {\n    (nextProps as Record<string, unknown>).children = normalizedChildren.length === 1 ? normalizedChildren[0] : normalizedChildren;\n  }\n  return {\n    type,\n    props: nextProps as Props & { children?: VNodeChildren },\n    key: key as string | number | null,\n    el: null,\n    children: normalizedChildren,\n    shapeFlag: typeof type === 'string' ? 1 : typeof type === 'function' ? 2 : 0\n  } as VNode<Props>;\n}\n\nexport function createTextVNode(text: string): TextVNode {\n  return {\n    type: TEXT_TYPE,\n    props: {} as Record<string, unknown> & { children?: VNodeChildren },\n    key: null,\n    el: null,\n    children: text,\n    shapeFlag: 0\n  } as TextVNode;\n}\n\nexport function isTextVNode(vnode: VNode | null | undefined): vnode is TextVNode {\n  return Boolean(vnode && vnode.type === TEXT_TYPE);\n}\n", "interface ScheduledJob {\n  job: () => void;\n  id: number;\n}\n\ntype Priority = 'immediate' | 'normal' | 'idle';\n\nconst queues: Record<Priority, Array<ScheduledJob>> = {\n  immediate: [],\n  normal: [],\n  idle: []\n};\n\nlet isFlushing = false;\nlet jobCounter = 0;\nconst pendingPostFlushCbs: Array<() => void> = [];\n\nconst nextTick = typeof queueMicrotask === 'function' ? queueMicrotask : (cb => Promise.resolve().then(cb));\n\nfunction scheduleFlush(): void {\n  if (isFlushing) return;\n  isFlushing = true;\n  nextTick(runQueues);\n}\n\nfunction runQueues(): void {\n  try {\n    flushQueue('immediate');\n    flushQueue('normal');\n    if (!queues.immediate.length && !queues.normal.length) {\n      flushQueue('idle');\n    }\n    flushPostFlushCbs();\n  } finally {\n    isFlushing = false;\n    if (hasPendingJobs()) {\n      scheduleFlush();\n    }\n  }\n}\n\nfunction flushQueue(priority: Priority): void {\n  const list = queues[priority];\n  let entry: ScheduledJob | undefined;\n  while ((entry = list.shift())) {\n    entry.job();\n  }\n}\n\nfunction flushPostFlushCbs(): void {\n  if (!pendingPostFlushCbs.length) return;\n  const cbs = [...new Set(pendingPostFlushCbs)];\n  pendingPostFlushCbs.length = 0;\n  for (const cb of cbs) {\n    cb();\n  }\n}\n\nfunction hasPendingJobs(): boolean {\n  return queues.immediate.length > 0 || queues.normal.length > 0 || queues.idle.length > 0;\n}\n\nexport function queueJob(job: () => void, priority: Priority = 'normal'): void {\n  const list = queues[priority];\n  if (!list.some(entry => entry.job === job)) {\n    list.push({ job, id: jobCounter++ });\n    scheduleFlush();\n  }\n}\n\nexport function withScheduler<T extends (...args: unknown[]) => unknown>(fn: T, priority: Priority = 'normal'): (...funcArgs: Parameters<T>) => void {\n  return (...args: Parameters<T>) => queueJob(() => fn(...args), priority);\n}\n\nexport function queuePostFlushCb(cb: () => void): void {\n  pendingPostFlushCbs.push(cb);\n  scheduleFlush();\n}\n\nexport function flushIdle(): void {\n  flushQueue('idle');\n}\n", "import type { VNode } from './vnode.gbln';\nimport { queueJob } from './scheduler.gbln';\n\nexport interface AppContext {\n  provides: Record<string, unknown>;\n}\n\nexport interface ComponentInstance<Props = Record<string, unknown>> {\n  uid: number;\n  vnode: VNode<Props>;\n  parent: ComponentInstance | null;\n  appContext: AppContext;\n  type: VNode<Props>['type'];\n  root: ComponentInstance | null;\n  next: VNode<Props> | null;\n  subTree: VNode | null;\n  update: (() => void) | null;\n  isMounted: boolean;\n  props: Props;\n  hooks: Array<unknown>;\n  hookIndex: number;\n  effects: Array<() => void>;\n  provides: Record<string, unknown>;\n  render: (props: Props) => VNode;\n  hostContainer: ParentNode | null;\n}\n\nlet currentInstance: ComponentInstance | null = null;\nlet instanceUid = 0;\n\nexport function createComponentInstance<Props>(vnode: VNode<Props>, parent: ComponentInstance | null): ComponentInstance<Props> {\n  const appContext: AppContext = vnode.appContext || (parent && parent.appContext) || { provides: Object.create(null) };\n\n  const instance: ComponentInstance<Props> = {\n    uid: instanceUid++,\n    vnode,\n    parent: parent || null,\n    appContext,\n    type: vnode.type,\n    root: parent ? parent.root : null,\n    next: null,\n    subTree: null,\n    update: null,\n    isMounted: false,\n    props: (vnode.props || {}) as Props,\n    hooks: [],\n    hookIndex: 0,\n    effects: [],\n    provides: parent ? Object.create(parent.provides) : Object.create(appContext.provides || null),\n    render: () => vnode,\n    hostContainer: null\n  };\n\n  if (!instance.root) {\n    instance.root = instance;\n  }\n\n  vnode.component = instance as unknown as ComponentInstance<unknown>;\n\n  return instance;\n}\n\nexport function setupComponent(instance: ComponentInstance): void {\n  const Component = instance.type;\n  if (typeof Component !== 'function') {\n    throw new Error('Goblin only supports function components at this time.');\n  }\n  instance.render = Component as (props: unknown) => VNode;\n}\n\nexport function prepareInstanceForRender(instance: ComponentInstance): void {\n  instance.hookIndex = 0;\n  instance.effects = [];\n}\n\nexport function setCurrentInstance(instance: ComponentInstance | null): void {\n  currentInstance = instance;\n}\n\nexport function resetCurrentInstance(): void {\n  currentInstance = null;\n}\n\nexport function getCurrentInstance(): ComponentInstance | null {\n  return currentInstance;\n}\n\nexport function updateComponentProps<Props>(instance: ComponentInstance<Props>, nextVNode: VNode<Props>): void {\n  instance.props = (nextVNode.props || {}) as Props;\n}\n\nexport function scheduleComponentUpdate(instance: ComponentInstance, updateFn: () => void): () => void {\n  instance.update = () => queueJob(updateFn);\n  return instance.update;\n}\n", "import { getCurrentInstance, scheduleComponentUpdate } from './component.gbln';\n\nfunction assertInstance() {\n  const instance = getCurrentInstance();\n  if (!instance) {\n    throw new Error('Hooks can only be used inside Goblin function components.');\n  }\n  return instance;\n}\n\nexport function useState(initialValue) {\n  const instance = assertInstance();\n  const index = instance.hookIndex++;\n  if (!(index in instance.hooks)) {\n    const value = typeof initialValue === 'function' ? initialValue() : initialValue;\n    instance.hooks[index] = value;\n  }\n  const setState = nextValue => {\n    const current = instance.hooks[index];\n    const value = typeof nextValue === 'function' ? nextValue(current) : nextValue;\n    if (!Object.is(value, current)) {\n      instance.hooks[index] = value;\n      if (instance.update) {\n        instance.update();\n      } else {\n        scheduleComponentUpdate(instance, () => {});\n      }\n    }\n  };\n  return [instance.hooks[index], setState];\n}\n\nexport function useReducer(reducer, initialArg, init) {\n  const instance = assertInstance();\n  const index = instance.hookIndex++;\n  if (!(index in instance.hooks)) {\n    instance.hooks[index] = init ? init(initialArg) : initialArg;\n  }\n  const dispatch = action => {\n    const value = instance.hooks[index];\n    const nextValue = reducer(value, action);\n    if (!Object.is(value, nextValue)) {\n      instance.hooks[index] = nextValue;\n      instance.update && instance.update();\n    }\n  };\n  return [instance.hooks[index], dispatch];\n}\n\nexport function useRef(initialValue) {\n  const instance = assertInstance();\n  const index = instance.hookIndex++;\n  if (!(index in instance.hooks)) {\n    instance.hooks[index] = { current: initialValue };\n  }\n  return instance.hooks[index];\n}\n\nexport function useMemo(factory, deps) {\n  const instance = assertInstance();\n  const index = instance.hookIndex++;\n  const hasDeps = Array.isArray(deps);\n  const record = instance.hooks[index];\n  if (!record) {\n    const value = factory();\n    instance.hooks[index] = { value, deps };\n    return value;\n  }\n  if (!hasDeps) {\n    const value = factory();\n    instance.hooks[index] = { value, deps };\n    return value;\n  }\n  const prevDeps = record.deps || [];\n  const changed = deps.length !== prevDeps.length || deps.some((dep, i) => !Object.is(dep, prevDeps[i]));\n  if (changed) {\n    const value = factory();\n    instance.hooks[index] = { value, deps };\n    return value;\n  }\n  return record.value;\n}\n\nexport function useEffect(effect, deps) {\n  const instance = assertInstance();\n  const index = instance.hookIndex++;\n  const record = instance.hooks[index] || { deps: undefined, cleanup: undefined };\n  const hasDeps = Array.isArray(deps);\n  const prevDeps = record.deps;\n  const changed = !hasDeps || !prevDeps || deps.length !== prevDeps.length || deps.some((dep, i) => !Object.is(dep, prevDeps[i]));\n\n  if (changed) {\n    instance.effects.push(() => {\n      if (typeof record.cleanup === 'function') {\n        record.cleanup();\n      }\n      const cleanup = effect();\n      instance.hooks[index] = {\n        deps,\n        cleanup: typeof cleanup === 'function' ? cleanup : undefined\n      };\n    });\n  } else {\n    instance.effects.push(() => {\n      instance.hooks[index] = record;\n    });\n  }\n}\n", "import { h } from './vnode.gbln';\nimport type { VNode } from './vnode.gbln';\nimport { useEffect, useState } from './hooks.gbln';\nimport { getCurrentInstance, scheduleComponentUpdate } from './component.gbln';\nimport { queueJob } from './scheduler.gbln';\n\ninterface SuspenseState {\n  status: 'pending' | 'resolved' | 'rejected';\n  vnode: VNode | null;\n  error: unknown;\n}\n\ninterface SuspenseProps {\n  fallback?: VNode | (() => VNode | null) | null;\n  children: VNode | (() => VNode | Promise<VNode | null> | null) | Promise<VNode | null> | null;\n}\n\ninterface ResourceOptions<Key, Params> {\n  key?: (params: Params) => Key;\n}\n\ninterface ResourceEntry<Value> {\n  status: 'pending' | 'resolved' | 'rejected';\n  value?: Value;\n  error?: unknown;\n  promise?: Promise<Value>;\n}\n\ninterface Resource<Value, Params> {\n  read(params: Params): Value;\n  preload(params: Params): Promise<Value>;\n  subscribe(params: Params, listener: () => void): () => void;\n  invalidate(params: Params): void;\n  clear(): void;\n  keyFor(params: Params): unknown;\n}\n\ninterface ResourceHookRecord {\n  key: unknown;\n  unsubscribe: (() => void) | null;\n  cleanup?: () => void;\n}\n\nfunction isPromise<T>(value: unknown): value is Promise<T> {\n  return Boolean(value) && typeof (value as Promise<T>).then === 'function';\n}\n\nasync function resolveVNode(candidate: SuspenseProps['children']): Promise<VNode | null> {\n  if (candidate == null) {\n    return null;\n  }\n  if (typeof candidate === 'function') {\n    return resolveVNode(candidate());\n  }\n  if (isPromise<VNode | null>(candidate)) {\n    const resolved = await candidate;\n    return resolveVNode(resolved);\n  }\n  if (Array.isArray(candidate)) {\n    return h('goblin-fragment', null, ...(candidate as Array<VNode>));\n  }\n  return candidate as VNode;\n}\n\nfunction renderFallback(fallback: SuspenseProps['fallback']): VNode | null {\n  if (typeof fallback === 'function') {\n    return fallback() ?? null;\n  }\n  return fallback ?? null;\n}\n\nexport function Suspense(props: SuspenseProps): VNode | null {\n  const [state, setState] = useState<SuspenseState>({ status: 'pending', vnode: null, error: null });\n\n  useEffect(() => {\n    let cancelled = false;\n    setState({ status: 'pending', vnode: null, error: null });\n    resolveVNode(props.children)\n      .then(vnode => {\n        if (!cancelled) {\n          setState({ status: 'resolved', vnode: vnode ?? null, error: null });\n        }\n      })\n      .catch(error => {\n        if (!cancelled) {\n          setState({ status: 'rejected', vnode: null, error });\n        }\n      });\n    return () => {\n      cancelled = true;\n    };\n  }, [props.children]);\n\n  if (state.status === 'resolved') {\n    return state.vnode;\n  }\n\n  if (state.status === 'rejected') {\n    throw state.error ?? new Error('Suspense child rejected without an error reason.');\n  }\n\n  return renderFallback(props.fallback);\n}\n\nfunction defaultKeyResolver(params: unknown): unknown {\n  if (params == null) {\n    return '__default__';\n  }\n  if (typeof params === 'string' || typeof params === 'number' || typeof params === 'boolean') {\n    return params;\n  }\n  try {\n    return JSON.stringify(params);\n  } catch (_error) {\n    return params;\n  }\n}\n\nexport function createResource<Value, Params = void>(\n  loader: (params: Params) => Promise<Value> | Value,\n  options: ResourceOptions<unknown, Params> = {}\n): Resource<Value, Params> {\n  const cache = new Map<unknown, ResourceEntry<Value>>();\n  const listeners = new Map<unknown, Set<() => void>>();\n  const key = options.key ?? defaultKeyResolver;\n\n  function notify(entryKey: unknown): void {\n    const set = listeners.get(entryKey);\n    if (!set) return;\n    for (const listener of set) {\n      listener();\n    }\n  }\n\n  function load(entryKey: unknown, params: Params): ResourceEntry<Value> {\n    const existing = cache.get(entryKey);\n    if (existing && existing.status === 'pending') {\n      return existing;\n    }\n    const record: ResourceEntry<Value> = { status: 'pending' };\n    const promise = Promise.resolve(loader(params));\n    record.promise = promise;\n    cache.set(entryKey, record);\n    promise\n      .then(value => {\n        record.status = 'resolved';\n        record.value = value;\n        notify(entryKey);\n      })\n      .catch(error => {\n        record.status = 'rejected';\n        record.error = error;\n        notify(entryKey);\n      });\n    return record;\n  }\n\n  function ensure(params: Params): { entryKey: unknown; record: ResourceEntry<Value> } {\n    const entryKey = key(params);\n    const record = cache.get(entryKey) ?? load(entryKey, params);\n    return { entryKey, record };\n  }\n\n  return {\n    read(params: Params): Value {\n      const { record } = ensure(params);\n      if (record.status === 'resolved') {\n        return record.value as Value;\n      }\n      if (record.status === 'rejected') {\n        throw record.error;\n      }\n      throw record.promise;\n    },\n    preload(params: Params): Promise<Value> {\n      const { record } = ensure(params);\n      if (record.status === 'resolved') {\n        return Promise.resolve(record.value as Value);\n      }\n      if (record.status === 'rejected') {\n        return Promise.reject(record.error);\n      }\n      return record.promise as Promise<Value>;\n    },\n    subscribe(params: Params, listener: () => void): () => void {\n      const { entryKey } = ensure(params);\n      let set = listeners.get(entryKey);\n      if (!set) {\n        set = new Set();\n        listeners.set(entryKey, set);\n      }\n      set.add(listener);\n      return () => {\n        const target = listeners.get(entryKey);\n        if (!target) return;\n        target.delete(listener);\n        if (target.size === 0) {\n          listeners.delete(entryKey);\n        }\n      };\n    },\n    invalidate(params: Params): void {\n      const entryKey = key(params);\n      cache.delete(entryKey);\n      notify(entryKey);\n    },\n    clear(): void {\n      cache.clear();\n      listeners.clear();\n    },\n    keyFor(params: Params): unknown {\n      return key(params);\n    }\n  };\n}\n\nexport function useResource<Value, Params = void>(resource: Resource<Value, Params>, params: Params): Value {\n  const instance = getCurrentInstance();\n  if (!instance) {\n    throw new Error('useResource must be called within a Goblin function component.');\n  }\n  const index = instance.hookIndex++;\n  let record = instance.hooks[index] as ResourceHookRecord | undefined;\n  const resourceKey = resource.keyFor(params);\n\n  if (!record || record.key !== resourceKey) {\n    if (record?.unsubscribe) {\n      record.unsubscribe();\n    }\n    const unsubscribe = resource.subscribe(params, () => {\n      queueJob(() => {\n        const trigger = scheduleComponentUpdate(instance, () => {});\n        trigger();\n      }, 'immediate');\n    });\n    record = {\n      key: resourceKey,\n      unsubscribe,\n      cleanup: () => {\n        unsubscribe();\n      }\n    };\n    instance.hooks[index] = record;\n  }\n\n  try {\n    return resource.read(params);\n  } catch (value) {\n    if (isPromise<Value>(value)) {\n      resource.preload(params).catch(() => {\n        /* noop: handled via subsequent read */\n      });\n    }\n    throw value;\n  }\n}\n", "import type { VNode } from './runtime/vnode.gbln';\nimport { h } from './runtime/vnode.gbln';\nimport { Suspense, createResource } from './runtime/suspense.gbln';\n\nexport interface AppProps {\n  title: string;\n  features?: Array<string>;\n}\n\nconst featureResource = createResource(async () => {\n  await new Promise(resolve => setTimeout(resolve, 20));\n  return ['fast', 'typed', 'suspense-ready'];\n});\n\nexport function App(props: AppProps): VNode {\n  const hasStaticFeatures = Array.isArray(props.features) && props.features.length > 0;\n  const staticItems = (props.features ?? []).map(label => h('li', { class: 'feature-item' }, label));\n\n  return h(\n    'main',\n    { class: 'goblin-app-shell' },\n    h('h1', null, props.title),\n    hasStaticFeatures\n      ? h('ul', { class: 'feature-list' }, staticItems)\n      : h(\n          Suspense,\n          {\n            fallback: () => h('p', { class: 'loading' }, 'Loading features...')\n          },\n          () =>\n            featureResource.preload(undefined).then(features => {\n              const items = features.map(label => h('li', { class: 'feature-item' }, label));\n              return items.length > 0\n                ? h('ul', { class: 'feature-list' }, items)\n                : h('p', null, 'Configure features in src/index.gbln to see them here.');\n            })\n        )\n  );\n}\n\nexport interface RootRenderer {\n  render(target: HTMLElement, props: AppProps): VNode;\n}\n\nexport function createRoot(): RootRenderer {\n  return {\n    render(target, props) {\n      const vnode = App(props);\n      target.dispatchEvent(new CustomEvent('goblin:render', { detail: { vnode } }));\n      target.textContent = JSON.stringify(vnode, null, 2);\n      return vnode;\n    }\n  };\n}\n\nexport default App;\n", "import type { VNode } from '../runtime/vnode.gbln';\n\nconst DEFAULT_CHUNK_SIZE = 1024;\n\nexport interface StreamOptions {\n  chunkSize?: number;\n  signal?: AbortSignal;\n}\n\nexport async function* renderVNodeToStream(\n  vnode: VNode,\n  options: StreamOptions = {}\n): AsyncGenerator<string, void, unknown> {\n  const chunkSize = Math.max(16, options.chunkSize ?? DEFAULT_CHUNK_SIZE);\n  const serialized = JSON.stringify(vnode);\n  for (let index = 0; index < serialized.length; index += chunkSize) {\n    if (options.signal?.aborted) {\n      break;\n    }\n    const chunk = serialized.slice(index, index + chunkSize);\n    yield chunk;\n    if (chunkSize > 64) {\n      await Promise.resolve();\n    }\n  }\n}\n\nexport async function collectStream(iterable: AsyncIterable<string>): Promise<string> {\n  let result = '';\n  for await (const chunk of iterable) {\n    result += chunk;\n  }\n  return result;\n}\n"],
  "mappings": "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",
  "names": []
}
